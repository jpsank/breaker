#!/usr/bin/env python3

"""
Christopher G. King, 2023

cgkdb: interval.py

Module handling chromosome intervals.
"""

#-----------------------------------------------------------------------------#
# Major questions:
#   1. Should the base ChrInterval have an alnseq attribute? Or should this
#      only belong to search result hits?
#   2. Should a ChrInterval instance have the ability to retreive its own
#      sequence context from a pyfaidx db? Should this modify the object or
#      return a new one?
#-----------------------------------------------------------------------------#

class ChrInterval:
    """
    Reprsents a chromosomal interval.

    accn   = specifies chromosomal accession
    start  = lower-valued coordinate
    end    = higher-valued coordinate
    strand = specifies strand ('+', '-', '.', or None)
    """
    __slots__ = ('chraccn', 'start', 'end', 'strand', 'alnseq')

    def __init__(self, chraccn, start, end, strand=None, alnseq=None):

        if strand not in (None, '+', '-', '.'):
            raise ValueError("Strand must be '+', '-', '-', or None")

        elif not isinstance(start, int) or not isinstance(end, int):
            raise ValueError("start and end must be int")

        elif end < start:
            raise ValueError("end cannot be less than start")

        self.chraccn = chraccn
        self.start   = start
        self.end     = end
        self.strand  = strand
        self.alnseq  = alnseq

    def __str__(self):
        return repr(self)

    def __repr__(self):
        return '%s(%s)' % (str(type(self).__name__), self.esltag)

    def __len__(self):
        return self.end - self.start + 1

    @property
    def coords(self):
        """
        Coordinate tuple in (start, end) format.
        """
        return self.start, self.end

    @property
    def eslcoords(self):
        """
        Coordinate tuple in (5prime, 3prime) format.
        """
        return self.coords[::-1] if self.strand == '-' else self.coords

    @property
    def esltag(self, sep='/', delim='-'):
        """
        Sequence tag used in Sto files generated by HMMER, Infernal, etc.
        """
        return sep.join([self.chraccn, delim.join(map(str, self.eslcoords))])

    @property
    def midpoint(self):
        """
        Midpoint coordinate (type double).
        """
        return (self.start + self.end) / 2

    def overlaps(self, other):
        """
        Tests for overlap between instance and another interval.
        Returns 1 for same strand, -1 for opposite strand overlap.
        Returns 0 if no overlap.
        """
        if self.chraccn != other.chraccn:
            raise ValueError('Cannot compare w/ different accns')
        sign = 2 * (self.strand == other.strand) - 1
        return sign * (
            not (self.end < other.start) and not (self.start > other.end))

    def contains(self, other):
        """
        Tests if instance contains another interval.
        Returns 1 for same strand, -1 for opposite strand overlap.
        Returns 0 if no overlap.
        """
        if self.chraccn != other.chraccn:
            raise ValueError('Cannot compare w/ different accns')
        sign = 2 * (self.strand == other.strand) - 1
        return sign * (
            self.start <= other.start and self.end >= other.end)

    def overlaps_any(self, others):
        """
        Tests if interval overlaps any other in an iterable.
        Returns a list of overlaps.
        """
        return [ other for other in others if self.overlaps(other) ]

    def contains_any(self, others):
        """
        Tests if interval contains any others in an iterable.
        Returns a list of all contained by interval.
        """
        return [ other for other in others if self.contains(other) ]

    def distance_to(self, other):
        """
        Calculates distance between two hits; 0 if overlap.
        """
        # NOTE this might need some add'l thinking
        if self.overlaps(other):
            return 0
        elif self.coords[1] < other.coords[0]:
            return other.coords[0] - self.coords[1]
        elif self.coords[0] > other.coords[1]:
            return self.coords[0] - other.coords[1]
        else:
            raise ValueError("How can this happen?")
    
    def getflanks(self, dbfna, nt5p=0, nt3p=0, sep=''):
        """Retreives sequence (with optional flanking nts) from dbfna.
        Returns:
            0) the flanking sequences retreived from dbfna
            1) a new coordinate pair expanded on 5'- and 3'-ends,
            2) a tuple of returned flanking nt values

        IMPORTANT: a call to getseq() IMPLIES retreival from dbfna
        """
        if not isinstance(nt5p, int) or not isinstance(nt3p, int):
            raise ValueError("flanking nt count must be int")
        elif nt5p < 0 or nt3p < 0:
            raise ValueError("flanking nt count must be positive")

        coords = self.eslcoords
        rc = coords[0] > coords[1]
        L = len(dbfna[self.chraccn])

        if rc:
            newcoords = (min(L, coords[0] + nt5p), max(1, coords[1] - nt3p))
            nt5p, nt3p = newcoords[0] - coords[0], coords[1] - newcoords[1]
        else:
            newcoords = (max(1, coords[0] - nt5p), min(L, coords[1] + nt3p))
            nt5p, nt3p = coords[0] - newcoords[0], newcoords[1] - coords[1]

        newseq = dbfna.get_seq(
            self.chraccn, min(newcoords), max(newcoords), rc=rc).seq.upper()

        # NOTE: better to return here, or have below as separate func?
        # Progressing further allows 2 things:
        #   1. comparison of retreived core seq to seq stored w object
        #   2. insertion of a gap char between core seq and flank seqs
        #   3. replacement of unaligned core seq w aligned core seq
        # --> For now I think one large function is better; perhaps it
        # can then be refactored to do more things, like 'get upstream seq'

        seq5p, seq3p = newseq[:nt5p], newseq[-nt3p:] if nt3p > 0 else ''
        seq = newseq[nt5p:len(newseq)-nt3p]

        return seq5p, seq3p, nt5p, nt3p


    @classmethod
    def from_esltag(cls, esltag, alnseq=None, sep='/', delim='-'):
        """
        Constructor from a <chraccn>/<eslcoords> esltag.
        """
        chraccn, coords = esltag.split(sep)
        c5p, c3p = tuple(map(int, coords.split(delim)))
        strand = '-' if c5p > c3p else '+'
        start, end = (c3p, c5p) if strand == '-' else (c5p, c3p)
        return cls(chraccn, start, end, strand, alnseq)

    @classmethod
    def from_multi_esltag(esltag, alnseq=None, sep='/', delim='-'):
        # Concept: a genomic sub-interval takes the form
        # NC_000913.3/10000-20000/433-576, where the second set of coords
        # is relative to the first. This can be mapped back to an absolute
        # set of coords
        raise NotImplementedError

    @staticmethod
    def split_esltag(esltag, sep='/', delim='-'):
        """
        Utility method to split an esltag of form <chraccn>/<eslcoords>
        into a tuple (chraccn, coords)
        """
        chraccn, coords = esltag.split(sep)
        coords = tuple(map(int, coords.split(delim)))
        return chraccn, coords

    @staticmethod
    def make_esltag(chraccn, eslcoords, sep='/', delim='-'):
        """
        Makes an esltag from chraccn and eslcoords
        """
        eslcoords = delim.join(map(str, eslcoords))
        return chraccn + sep + eslcoords



